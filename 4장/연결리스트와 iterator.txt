인터페이스(interface)와 구현(implementation)의 분리
	연결 리스트는 "list"라는 추상적인 데이터 타입을 구현하는 한 가지 방법임
		**사용자는 이러한 리스트에 데이터를 삽입, 삭제, 검색만 할 수 있으면 됨
	=> 인터페이스와 구현을 분리하면 코드의 모듈성이 증가하며, 코드의 유지/보수,코드의 재사용이 용이해짐
		**이때 사용자는 인터페이스만 알면 되고 implementation은 알 필요없음 => 데이터 은닉

inner 클래스 : 클래스 안에 있는 클래스로 보통 private 제어자를 사용함
	**inner클래스를 해당 클래스에서만 사용하며 외부에 노출하지 않기위함
	=> inner 클래스를 기존에 사용하던 클래스에서 관련된 모든 오류가 발생함


연결리스트의 순회: Iterator의 필요
Iterator
: 노드의 주소를 직접 사용자에게 제공하는 대신 그것을 private 멤버로 wrapping하고 있으면서 
사용자가 필요로 하는 일을 해주는 public method를 가진 Iterator 객체를 제공함
	**개념적 의미: 연결리스트의 노드와 노드 사이를 가리킴
		iterator는 이전 노드를 지나치고 다음 노드를 가리키는 방식을 사용함
		=> 이는 일반적으로 필드를 가리킴과 동시에 조건을 확인하는 것이 아닌 필드를 확인한 시점에서 조건을 비교하는 식


	** Java API에서 제공해주는 기능(java.util.iterator)
	제공 메서드
		public E next();		: 현재 노드의 데이터를 반환하고 한 컨 전진함
		public boolean hasNext();	: 다음 노드가 존재하는지 검사함(있으면 true, 없으면 false)
		public void remove()	: 가장 최근에 next() 메서드로 반환한 노드를 삭제함


단방향 연결 리스트의 한계
: 단방향 순회만 가능해 어떤 노드 앞에 새로운 노드를 삽입하기 어려움
	**이는 삭제하는 경우에도 동일함

=>
이중 연결 리스트
:각 노드가 다음 노드와 이전 노드의 주소를 가지는 연결 리스트
	**양방향의 순회가 가능함
	구조
	: head(tail, size), node(next, prev, data)

	노드 삽입
	: 다음 노드 주소 저장 -> 이전 노드 주소 저장 -> 다음 노드의 이전 노드 주소 저장 -> 이전 노드의 다음 노드 주소 저장

	노드 삭제
	: 이전 노드의 다음 노드 주소 삭제 -> 다음 노드의 이전 노드 주소 삭제


Iterator의 한계
: 단방향으로만 순회할 수 있어 항상 리스트의 처음에서 시작함
	**remove 메서드는 지원하지만, add 메서드는 지원하지 않음
	인터페이스
	: add(E obj), hasNext(), hasPrevious(), next(), nextIndex(), previous(), previousIndex(), remove(), set(E obj)

**Generic 변수는 반드시 같지 않아도 되고 static의 경우에는 non-static과 다르게 하는게 더 좋다


Java Collection Framework
KWLinkedList는 LinkedList의 기본 기능만을 구현한 클래스로 기존에 다양한 클래스가 이미 존재함


Enhanced for문
	형식
	for(변수타입 변수 : 변수명){	
	
	}


원형 리스트
	원형 이중연결 리스트
		**마지막 노드의 다음 노드가 첫 번째 노드가 됨
		**반대로 첫 노드의 이전 노드가 마지막 노드가 됨